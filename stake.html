<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>TruVesta - Staking</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&family=Playfair+Display:wght@700;900&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js"></script>

  <style>
    /* === LUXURIOUS THEME VARIABLES === */
    :root{
      --bg-0: #1C1C1E; --bg-1: #2C2C2E; --bg-2: #404043;
      --txt-1: #E0E0E0; --txt-2: #A0A0A0;
      --pri-color: #D4AF37; --pri-gradient: linear-gradient(90deg, #D4AF37, #FFD700);
      --btn-bg: #D4AF37; --btn-txt: #1C1C1E;
      --good: #34D399; --bad: #F87171; --warn: #FBBF24;
      --edge: rgba(212, 175, 55, .2);
      --glow: 0 4px 15px rgba(0,0,0,.5);
      --radius: 14px;
      --input-bg: #404043;
    }

    body.light-theme {
        --bg-0: #F2F2F7; --bg-1: #FFFFFF; --bg-2: #E5E5EA;
        --txt-1: #1C1C1E; --txt-2: #8E8E93;
        --edge: rgba(0, 0, 0, 0.1); --glow: 0 4px 15px rgba(0,0,0,0.08);
        --input-bg: #E5E5EA; --btn-txt: #1C1C1E; 
    }

    *{box-sizing:border-box}
    body{
      margin:0; padding-bottom: 80px;
      font-family: Inter, system-ui, sans-serif;
      color:var(--txt-1); background-color: var(--bg-0);
      letter-spacing:.2px; min-height: 100dvh;
      transition: background-color 0.3s ease, color 0.3s ease;
    }
    body::-webkit-scrollbar {display: none;}

    .app{display:flex; flex-direction:column; position: relative; min-height: 100dvh;}
    .main{padding:16px; display:flex; flex-direction:column; gap:16px;}

    /* HEADER */
    .header{display:flex; gap:14px; align-items:center; justify-content:space-between; padding: 4px 0;}
    .header .app-title {
        font-family: 'Playfair Display', serif; font-weight: 900; font-size: 24px; color: var(--pri-color); letter-spacing: 1px;
    }
    .header .btn-icon {
      width: 40px; height: 40px; display: grid; place-items: center; font-size: 18px;
      background: transparent; border: 0; color: var(--txt-2); cursor: pointer; transition: color 0.2s;
    }
    .header .btn-icon:hover { color: var(--pri-color); }

    /* BUTTONS */
    .btn{
      padding:10px 14px; border-radius:10px; border: 0;
      color:var(--txt-1); background: var(--bg-2); cursor:pointer;
      font-size: 14px; font-weight: 500; transition: background .2s, transform 0.1s;
    }
    .btn:active { transform: scale(0.98); }
    .btn.primary{
      background: var(--btn-bg); color: var(--btn-txt); font-weight: 700;
      box-shadow: 0 4px 10px rgba(212, 175, 55, 0.4); 
    }
    .btn:disabled { opacity: 0.5; cursor: not-allowed; box-shadow: none; }

    /* CARDS */
    .card{
      background: var(--bg-1); border:1px solid var(--edge); 
      border-radius: var(--radius); box-shadow: var(--glow);
    }
    .card .head{
      display:flex; align-items:center; justify-content:space-between; 
      padding:14px 16px; border-bottom:1px solid var(--edge);
    }
    .card .head h3{margin:0; font-size:17px; font-weight:700; color: var(--pri-color);}
    .card .body{padding:16px;}

    /* NAV */
    .bottom-nav{
      position:fixed; bottom:0; left:0; right:0; height: 65px;
      display:flex; align-items:center; justify-content: space-around;
      background: var(--bg-1); border-top: 1px solid var(--edge); z-index: 1000;
      box-shadow: 0 -5px 30px rgba(0,0,0,.5);
    }
    .bottom-nav a, .bottom-nav button{
      flex:1; display:flex; flex-direction: column; align-items: center; justify-content: center;
      text-decoration: none; color: var(--txt-2); font-size: 10px; font-weight: 500; gap: 4px; padding: 8px 0;
      transition: color .2s; background: none; border: none; cursor: pointer; font-family: inherit;
    }
    .bottom-nav a i, .bottom-nav button i{font-size: 20px;}
    .bottom-nav a.active, .bottom-nav button.active{color: var(--pri-color); font-weight: 700;}

    /* FORM ELEMENTS */
    .form-group{margin-bottom:16px;}
    .form-group label{font-size:12px; color:var(--txt-2); margin-left:4px; display:block; margin-bottom: 4px;}
    .form-group input, .form-group select {
        width:100%; padding:14px; background:var(--bg-2); border:1px solid var(--edge); 
        color:var(--txt-1); border-radius:12px; outline:none; font-size: 16px;
        transition: border-color 0.3s, box-shadow 0.3s;
    }
    .form-group input:focus, .form-group select:focus {
        border-color: var(--pri-color); box-shadow: 0 0 0 2px rgba(212, 175, 55, 0.15);
    }
    .input-addon-container { position: relative; }
    .input-addon-container .addon {
        position: absolute; right: 14px; top: 50%; transform: translateY(-50%);
        color: var(--txt-2); font-weight: 600; font-size: 14px; pointer-events: none;
    }

    /* STAKE LIST */
    .stake-list { display: flex; flex-direction: column; gap: 12px; }
    .stake-item {
        background: var(--bg-2); border: 1px solid var(--edge); border-radius: 12px; padding: 14px 16px; 
    }
    .stake-item-header {
        display: flex; justify-content: space-between; align-items: center;
        border-bottom: 1px solid var(--edge); padding-bottom: 10px; margin-bottom: 10px;
    }
    .stake-item-header .symbol { font-weight: 700; font-size: 18px; color: var(--pri-color); }
    .stake-item-details { display: flex; flex-direction: column; gap: 8px; }
    .detail-row { display: flex; justify-content: space-between; font-size: 14px; }
    .detail-label { color: var(--txt-2); }
    .detail-value { font-weight: 600; color: var(--txt-1); }
    .progress-bar {
        height: 6px; background: var(--bg-1); border-radius: 3px; margin-top: 5px; overflow: hidden;
    }
    .progress-bar-fill { height: 100%; background: var(--good); transition: width 0.5s ease-in-out; }
    .reward-status { 
        display: flex; flex-direction: column; gap: 8px; padding-top: 10px; margin-top: 10px; border-top: 1px solid var(--edge); 
    }
    .status-msg { margin-top: 15px; font-size: 13px; color: var(--warn); }
    .stake-item.pending { border-color: var(--warn); } 
    .stake-item.active { border-color: var(--good); }

    input[readonly] { background-color: var(--bg-1); color: var(--txt-2); cursor: not-allowed; border-color: var(--edge); }

    /* MODAL */
    .modal-overlay {
        position: fixed; top: 0; left: 0; right: 0; bottom: 0;
        background: rgba(0, 0, 0, 0.7); backdrop-filter: blur(5px);
        display: flex; align-items: center; justify-content: center;
        z-index: 2000; opacity: 0; pointer-events: none; transition: opacity 0.3s ease;
    }
    .modal-overlay.show { opacity: 1; pointer-events: all; }
    .custom-dialog {
        background: var(--bg-1); width: 90%; max-width: 350px; border-radius: 20px;
        border: 1px solid var(--edge); box-shadow: 0 10px 40px rgba(0,0,0,0.5);
        transform: translateY(20px); transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        overflow: hidden;
    }
    .modal-overlay.show .custom-dialog { transform: translateY(0); }
    .dialog-header {
        background: var(--bg-2); padding: 15px 20px; border-bottom: 1px solid var(--edge);
        display: flex; justify-content: space-between; align-items: center;
    }
    .dialog-title {
        font-family: 'Playfair Display', serif; color: var(--pri-color); font-size: 18px; font-weight: 700; margin: 0;
    }
    .dialog-body { padding: 20px; text-align: center; color: var(--txt-1); font-size: 15px; line-height: 1.5; }
    .dialog-actions { display: flex; gap: 10px; padding: 0 20px 20px 20px; }
    .dialog-btn { flex: 1; padding: 12px; border-radius: 10px; border: none; font-weight: 600; cursor: pointer; font-size: 14px; }
    .btn-cancel { background: var(--bg-2); color: var(--txt-2); }
    .btn-confirm { background: var(--pri-color); color: var(--btn-txt); }
  </style>
</head>
<body>

  <div id="customModal" class="modal-overlay">
      <div class="custom-dialog">
          <div class="dialog-header"><h3 class="dialog-title" id="modalTitle">Notification</h3></div>
          <div class="dialog-body" id="modalMessage">Message goes here...</div>
          <div class="dialog-actions">
              <button class="dialog-btn btn-cancel" id="modalCancelBtn" onclick="closeModal(false)">Cancel</button>
              <button class="dialog-btn btn-confirm" id="modalConfirmBtn" onclick="closeModal(true)">Confirm</button>
          </div>
      </div>
  </div>

  <div class="app">
    <main class="main">
      <header class="header">
        <button class="btn-icon" onclick="window.location.href='assets.html'"><i class="fa-solid fa-arrow-left"></i></button>
        <span class="app-title">Staking Hub</span>
        <button onclick="toggleTheme()" id="themeToggleBtn" class="btn-icon"><i class="fa-solid fa-moon"></i></button>
      </header>

      <div class="card" id="global-stake-overview">
        <div class="head"><h3>Portfolio Stakes</h3></div>
        <div class="body" style="display: flex; flex-direction: column; gap: 15px;">
          <div style="display: flex; justify-content: space-between;">
            <span style="font-size: 15px; color: var(--txt-2);">Total Staked Value</span>
            <span id="totalStakedValue" style="font-size: 15px; font-weight: 600; color: var(--txt-1);">$0.00</span>
          </div>
          <div style="display: flex; justify-content: space-between;">
            <span style="font-size: 15px; color: var(--txt-2);">Available Rewards</span>
            <span id="totalAvailableRewards" style="font-size: 15px; font-weight: 600; color: var(--pri-color);">$0.00</span>
          </div>
          <p id="rewardPeriodInfo" style="font-size: 11px; color: var(--txt-2); text-align: right; margin: -10px 0 0 0;">
            Rewards credit every: <span id="rewardPeriodDisplay" style="color: var(--txt-1); font-weight: 600;">24 Hours</span>
          </p>

          <button class="btn primary" id="withdrawRewardsBtn" onclick="withdrawAllRewards()" disabled style="width:100%; padding:14px; font-size:16px; margin-top: 10px;">
              Withdraw All Rewards
          </button>
        </div>
      </div>

      <div class="card" id="create-stake-card">
        <div class="head"><h3>New Stake</h3></div>
        <div class="body">
          <div class="form-group">
            <label for="stakeCoin">Coin to Stake</label>
            <select id="stakeCoin" style="font-weight: 600;">
              <option value="">Loading Balances...</option>
            </select>
          </div>
          <div class="form-group">
            <label for="stakeAmount">Amount to Lock</label>
            <div class="input-addon-container">
                <input id="stakeAmount" type="number" placeholder="0.00" min="0.001">
                <span class="addon" id="stakeCoinSymbol">--</span>
            </div>
            <div style="display:flex; justify-content:space-between; margin-top:6px;">
                 <p id="stakeBalanceInfo" style="font-size: 12px; color: var(--txt-2); margin:0;">Available: 0.00 --</p>
                 <p id="dynamicRateInfo" style="font-size: 12px; color: var(--pri-color); font-weight:600; margin:0;">
                     0.00% / Period &nbsp;|&nbsp; Est. Return: $0.00
                 </p>
            </div>
          </div>
          <div class="form-group">
            <label for="stakeDuration">Staking Period (Fixed)</label>
            <div class="input-addon-container">
                <input id="stakeDurationDisplay" type="text" value="250 Days" readonly style="font-weight: 600;">
                <span class="addon"><i class="fa-solid fa-lock" style="font-size: 14px; color: var(--txt-2);"></i></span>
            </div>
            <p id="apyInfo" style="font-size: 12px; color: var(--warn); margin-top: 6px;">
                Interest credited per reward period.<br>
                <span style="color:var(--txt-2);">Withdrawal unlock depends on stake amount (10% - 30% completion).</span>
            </p>
          </div>
          <button class="btn primary" id="confirmStakeBtn" onclick="confirmStake()" style="width:100%; padding:14px; font-size:16px;">
              Confirm Stake
          </button>
        </div>
      </div>

      <div class="card" id="active-stakes-card">
        <div class="head"><h3>Your Active Stakes</h3></div>
        <div class="body">
          <p id="noStakesMessage" style="text-align:center; color:var(--txt-2); margin-bottom: 16px;">No active stakes found.</p>
          <div class="stake-list" id="activeStakesList"></div>
        </div>
      </div>
    </main>
  </div> 

  <nav class="bottom-nav">
      <button onclick="window.location.href='referral.html'">
          <i class="fa-solid fa-user-group"></i><span>Referral</span>
      </button>
      <button class="active" onclick="window.location.reload()">
          <i class="fa-solid fa-layer-group"></i><span>Stake</span>
      </button>
      <a href="assets.html" title="Assets"><i class="fa-solid fa-wallet"></i><span>Assets</span></a>
      <a href="profile.html" title="Profile"><i class="fa-solid fa-user"></i><span>Profile</span></a>
  </nav>

  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>

  <script>
    // --- FIREBASE INIT ---
    const firebaseConfig = {
      apiKey: "AIzaSyByvett5gGhga0jx2pBChmg41IKaTvbY24",
      authDomain: "bustrack-e4f8f.firebaseapp.com",
      databaseURL: "https://bustrack-e4f8f-default-rtdb.firebaseio.com",
      projectId: "bustrack-e4f8f",
      storageBucket: "bustrack-e4f8f.firebasestorage.app",
      messagingSenderId: "544737954134",
      appId: "1:544737954134:web:91a197cc88d0a67c43eef7"
    };
    const app = firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const database = firebase.database();

    // --- THEME LOGIC ---
    function initTheme() {
        const savedTheme = localStorage.getItem('theme');
        if (savedTheme === 'light') { document.body.classList.add('light-theme'); }
        updateThemeIcon();
    }
    function toggleTheme() {
        document.body.classList.toggle('light-theme');
        const isLight = document.body.classList.contains('light-theme');
        localStorage.setItem('theme', isLight ? 'light' : 'dark');
        updateThemeIcon();
    }
    function updateThemeIcon() {
        const btn = document.getElementById('themeToggleBtn');
        if(!btn) return; 
        const isLight = document.body.classList.contains('light-theme');
        btn.innerHTML = isLight ? '<i class="fa-solid fa-sun" style="color: var(--pri-color);"></i>' : '<i class="fa-solid fa-moon"></i>';
    }
    initTheme();

    // --- MODAL LOGIC ---
    let modalResolver = null;
    function openModal(title, message, isConfirm = false) {
        document.getElementById('modalTitle').textContent = title;
        document.getElementById('modalMessage').innerHTML = message.replace(/\n/g, '<br>');
        const cancelBtn = document.getElementById('modalCancelBtn');
        const confirmBtn = document.getElementById('modalConfirmBtn');
        if (isConfirm) { cancelBtn.style.display = 'block'; confirmBtn.textContent = 'Confirm'; } 
        else { cancelBtn.style.display = 'none'; confirmBtn.textContent = 'OK'; }
        document.getElementById('customModal').classList.add('show');
        return new Promise((resolve) => { modalResolver = resolve; });
    }
    function closeModal(result) {
        document.getElementById('customModal').classList.remove('show');
        if (modalResolver) { modalResolver(result); modalResolver = null; }
    }
    async function showAlert(message, title = 'Notification') { await openModal(title, message, false); }
    async function showConfirm(message, title = 'Confirm Action') { return await openModal(title, message, true); }

    // --- STAKING LOGIC ---
    const GLOBAL_RULES_PATH = 'globalStakingRules';
    let GLOBAL_REWARD_PERIOD_MS = 86400000; 
    let GLOBAL_REWARD_PERIOD_TEXT = "24 Hours";
    let STAKE_TIERS = [
        { max: 49, rate: 0.01 }, { max: 99, rate: 0.012 }, { max: 249, rate: 0.015 },
        { max: 499, rate: 0.017 }, { max: 999, rate: 0.02 }, { max: 1499, rate: 0.022 },
        { max: 2499, rate: 0.025 }, { max: 5000, rate: 0.027 }, { max: 99999999999, rate: 0.03 }
    ];
    let DEFAULT_WITHDRAW_LIMITS = [
        { max: 249, percent: 0.10 }, { max: 999, percent: 0.15 }, { max: 2499, percent: 0.20 },
        { max: 4999, percent: 0.25 }, { max: Infinity, percent: 0.30 }
    ];
    let currentWithdrawLimits = [...DEFAULT_WITHDRAW_LIMITS];
    const FIXED_DURATION_DAYS = 250; 
    let userId = null;
    let latestPrices = {}; 
    let activeStakes = {}; 
    let userBalances = {}; 
    let fetchedAddresses = {}; 
    const REQUIRED_COINS = ['btc', 'eth', 'usdt', 'trx', 'bnb', 'sol', 'xrp'];
    const COINGECKO_ID_MAP = { 'BTC': 'bitcoin', 'ETH': 'ethereum', 'BNB': 'binancecoin', 'SOL': 'solana', 'XRP': 'ripple', 'USDT': 'tether', 'TRX': 'tron' };
    const USER_ADDRESSES_PATH = 'privilegesecdata/';
    const USER_HOLDINGS_PATH = 'userHoldings/'; 

    auth.onAuthStateChanged((user) => {
      if (user) {
        userId = user.uid;
        checkAndInitGlobalRules();
        listenToGlobalRules();
        fetchAndInitPublicAddresses(user.uid);
        listenForActiveStakes();
        fetchLivePrices();
      } else { window.location.href = 'index.html'; }
    });

    function checkAndInitGlobalRules() {
        const ref = database.ref(GLOBAL_RULES_PATH);
        ref.get().then((snapshot) => {
            if (!snapshot.exists()) {
                const defaultRules = { tiers: STAKE_TIERS, withdrawLimits: DEFAULT_WITHDRAW_LIMITS, rewardPeriodMs: 86400000 };
                ref.set(defaultRules);
            }
        });
    }

    function listenToGlobalRules() {
        database.ref(GLOBAL_RULES_PATH).on('value', (snapshot) => {
            const data = snapshot.val();
            if (data) {
                if (data.tiers) STAKE_TIERS = data.tiers.map(t => ({ max: t.max > 90000000000 ? Infinity : t.max, rate: t.rate }));
                if (data.withdrawLimits) currentWithdrawLimits = data.withdrawLimits;
                GLOBAL_REWARD_PERIOD_MS = parseInt(data.rewardPeriodMs) || 86400000;
                const minutes = GLOBAL_REWARD_PERIOD_MS / 60000;
                GLOBAL_REWARD_PERIOD_TEXT = minutes >= 60 ? (minutes/60 % 1 === 0 ? minutes/60 + " Hour(s)" : (minutes/60).toFixed(1) + " Hours") : minutes + " Minute(s)";
                const periodDisplay = document.getElementById('rewardPeriodDisplay');
                if(periodDisplay) periodDisplay.innerText = GLOBAL_REWARD_PERIOD_TEXT;
            }
            if(Object.keys(activeStakes).length > 0) renderActiveStakes();
            updateEstimatedRate(); 
        });
    }

    function getRateForUsdAmount(usdAmount) {
        if (!usdAmount || usdAmount < 0) return 0.01;
        for (let tier of STAKE_TIERS) { if (usdAmount <= tier.max) return tier.rate; }
        return 0.03; 
    }
    function getMinWithdrawPercentage(usdAmount) {
        if (!usdAmount || usdAmount < 0) return 0.10;
        for (let limit of currentWithdrawLimits) { if (usdAmount <= limit.max) return limit.percent; }
        return 0.30;
    }
    function updateEstimatedRate() {
        const amount = parseFloat(document.getElementById('stakeAmount').value);
        const coin = document.getElementById('stakeCoin').value;
        const rateLabel = document.getElementById('dynamicRateInfo');
        if (!coin || isNaN(amount) || amount <= 0) {
            rateLabel.innerHTML = `0.00% / ${GLOBAL_REWARD_PERIOD_TEXT} &nbsp;|&nbsp; Est. Return: $0.00`; return;
        }
        const price = latestPrices[coin]?.price || 0;
        const periodRate = getRateForUsdAmount(amount * price);
        const totalDurationMs = FIXED_DURATION_DAYS * 24 * 60 * 60 * 1000;
        const totalPeriods = totalDurationMs / GLOBAL_REWARD_PERIOD_MS;
        const totalRewardUSD = (amount * periodRate * totalPeriods) * price;
        rateLabel.innerHTML = `${(periodRate * 100).toFixed(2)}% / ${GLOBAL_REWARD_PERIOD_TEXT} &nbsp;|&nbsp; Est. Return: <span style="color:var(--good)">$${fmt(totalRewardUSD, 2)}</span>`;
    }
    document.getElementById('stakeAmount').addEventListener('input', updateEstimatedRate);

    function fetchAndInitPublicAddresses(userId) {
        const path = USER_ADDRESSES_PATH + userId;
        const ref = database.ref(path);
        ref.get().then((snapshot) => {
            const data = snapshot.val();
            if (!data) {
                let init = {}; REQUIRED_COINS.forEach(c => init[c] = '');
                ref.set(init); fetchedAddresses = init;
            } else { fetchedAddresses = data; }
            if (Object.values(fetchedAddresses).some(a => a)) fetchLiveBalances(); 
            else renderStakeForm(); 
        }).catch(() => renderStakeForm());
    }

    async function fetchLiveBalances() {
        if (typeof ethers === 'undefined') return;
        const fetchBalance = async (coin, address) => {
            if (!address) return 0.0;
            try {
                if(coin === 'ETH') return parseFloat(ethers.utils.formatEther(await new ethers.providers.JsonRpcProvider("https://eth.llamarpc.com").getBalance(address)));
                if(coin === 'BNB') return parseFloat(ethers.utils.formatEther(await new ethers.providers.JsonRpcProvider("https://bsc-dataseed.binance.org/").getBalance(address)));
                if(coin === 'USDT') {
                    if(!address.startsWith('T')) return 0.0;
                    const d = await (await fetch(`https://api.trongrid.io/v1/accounts/${address}`)).json();
                    let b = 0; if(d.data?.[0]?.trc20) d.data[0].trc20.forEach(t => { if(t['TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t']) b = parseFloat(t['TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t']); });
                    return b/1000000;
                }
                if(coin === 'BTC') return (await (await fetch(`https://api.blockcypher.com/v1/btc/main/addrs/${address}/balance`)).json()).balance / 100000000 || 0;
                if(coin === 'TRX') return (await (await fetch(`https://api.trongrid.io/wallet/getaccount`, {method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({address,visible:true})})).json()).balance / 1000000 || 0;
                if(coin === 'SOL') return (await (await fetch(`https://api.mainnet-beta.solana.com`, {method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({"jsonrpc":"2.0","id":1,"method":"getBalance","params":[address]})})).json()).result?.value / 1000000000 || 0;
                if(coin === 'XRP') return parseFloat((await (await fetch(`https://s1.ripple.com:51234`, {method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({"method":"account_info","params":[{"account":address,"ledger_index":"current"}]})})).json()).result?.account_data?.Balance) / 1000000 || 0;
            } catch { return 0.0; }
        };
        const bals = await Promise.all(['ETH','BNB','USDT','BTC','TRX','SOL','XRP'].map(c => fetchBalance(c, fetchedAddresses[c.toLowerCase()])));
        ['ETH','BNB','USDT','BTC','TRX','SOL','XRP'].forEach((c,i) => userBalances[c] = bals[i] || 0);
        renderStakeForm(); 
    }
    function fmt(n, p=2){
      const num = parseFloat(n); if (isNaN(num)) return '0.00';
      return num.toLocaleString(undefined,{ minimumFractionDigits: Math.abs(num)<1?6:2, maximumFractionDigits: Math.abs(num)<1?6:2 });
    }
    async function fetchLivePrices() {
        try {
            const data = await (await fetch(`https://api.coingecko.com/api/v3/simple/price?ids=${Object.values(COINGECKO_ID_MAP).join(',')}&vs_currencies=usd`)).json();
            for (const [sym, id] of Object.entries(COINGECKO_ID_MAP)) { if (data[id]) latestPrices[sym] = { price: data[id].usd }; }
            updateEstimatedRate(); if(Object.keys(activeStakes).length > 0) renderActiveStakes();
        } catch { fetchMockPrices(); }
    }
    function fetchMockPrices() {
        latestPrices = { 'ETH': { price: 3500 }, 'BNB': { price: 600 }, 'USDT': { price: 1 }, 'BTC': { price: 65000 }, 'SOL': { price: 150 }, 'XRP': { price: 0.5 }, 'TRX': { price: 0.12 } };
        updateEstimatedRate();
    }
    function renderStakeForm() {
        const select = document.getElementById('stakeCoin'); select.innerHTML = '';
        const getLockedAmount = (c) => Object.values(activeStakes).reduce((a,s) => (s.coin===c && (s.status==='ACTIVE'||s.status==='PENDING') ? a+parseFloat(s.amount) : a), 0);
        REQUIRED_COINS.forEach(c => {
            const C = c.toUpperCase(); const net = Math.max(0, (userBalances[C]||0) - getLockedAmount(C));
            const opt = document.createElement('option'); opt.value = C; opt.textContent = `${C} (${fmt(net, 4)})`; select.appendChild(opt);
        });
        if (select.options.length === 0) { 
            const opt = document.createElement('option'); opt.text='No Balance'; opt.disabled=true; select.add(opt); document.getElementById('confirmStakeBtn').disabled=true;
        } else { document.getElementById('confirmStakeBtn').disabled=false; }
        select.onchange = updateStakeFormInfo; updateStakeFormInfo();
    }
    function updateStakeFormInfo() {
        const coin = document.getElementById('stakeCoin').value; if(!coin) return;
        const getLocked = (c) => Object.values(activeStakes).reduce((a,s) => (s.coin===c && (s.status==='ACTIVE'||s.status==='PENDING') ? a+parseFloat(s.amount) : a), 0);
        const net = Math.max(0, (userBalances[coin]||0) - getLocked(coin));
        document.getElementById('stakeCoinSymbol').textContent = coin;
        const bd = document.getElementById('stakeBalanceInfo');
        bd.textContent = net <= 0.000001 ? 'Insufficient Balance' : `Available: ${fmt(net, 4)} ${coin}`;
        bd.style.color = net <= 0.000001 ? 'var(--bad)' : 'var(--txt-2)';
        updateEstimatedRate();
    }
    function listenForActiveStakes() {
        if (!userId) return;
        database.ref('userStakes/' + userId).on('value', (snapshot) => { activeStakes = snapshot.val() || {}; renderActiveStakes(); renderStakeForm(); });
    }
    function renderActiveStakes() {
        const container = document.getElementById('activeStakesList'); container.innerHTML = ''; 
        let totalStakedUSD = 0, totalAvailRewardsUSD = 0, hasActive = false, hasStakes = Object.keys(activeStakes).length > 0;
        document.getElementById('noStakesMessage').style.display = hasStakes ? 'none' : 'block';
        if (!hasStakes) { document.getElementById('totalStakedValue').textContent = '$0.00'; document.getElementById('totalAvailableRewards').textContent = '$0.00'; return; }

        for (const id in activeStakes) {
            const s = activeStakes[id];
            const locked = parseFloat(s.amount), price = latestPrices[s.coin]?.price || 0, usd = locked * price;
            const isPending = s.status === 'PENDING';
            let earned = 0, avail = 0, yieldP = 0, completeP = 0, canW = false, statusTxt = 'Active', statusClr = 'var(--good)';
            const reqComp = getMinWithdrawPercentage(usd);
            
            if (!isPending) {
                const now = new Date(), start = new Date(s.startTime), end = new Date(start.getTime() + (s.durationDays*86400000));
                const periods = Math.floor((now - start) / GLOBAL_REWARD_PERIOD_MS);
                earned = periods > 0 ? (locked * (s.dailyRate||0.01) * periods) : 0;
                avail = earned - parseFloat(s.rewardsWithdrawn||0);
                yieldP = (earned/locked)*100;
                completeP = Math.min(100, ((now - start) / (end - start)) * 100);
                canW = completeP >= (reqComp * 100);
                if (completeP >= 100) statusTxt = 'Completed';
                totalStakedUSD += usd; totalAvailRewardsUSD += avail * price;
                if (avail > 0.000001 && canW) hasActive = true;
            } else { statusTxt = 'Pending Approval'; statusClr = 'var(--warn)'; }

            container.innerHTML += `
            <div class="stake-item ${isPending ? 'pending' : 'active'}">
                <div class="stake-item-header"><span class="symbol">${s.coin} Stake</span><span style="font-size:12px;color:${statusClr};font-weight:600;">${statusTxt}</span></div>
                <div class="stake-item-details">
                    <div class="detail-row"><span class="detail-label">Locked</span><span class="detail-value">${fmt(locked, 4)} ${s.coin} (~$${fmt(usd,0)})</span></div>
                    <div class="detail-row"><span class="detail-label">Rate</span><span class="detail-value">${(s.dailyRate*100).toFixed(2)}% / ${GLOBAL_REWARD_PERIOD_TEXT}</span></div>
                    <div class="detail-row"><span class="detail-label">End Date</span><span class="detail-value">${isPending?s.durationDays+' Days':new Date(s.startTime + s.durationDays*86400000).toLocaleDateString()}</span></div>
                    ${!isPending ? `<div class="detail-row"><span class="detail-label">Yield</span><span class="detail-value">${yieldP.toFixed(2)}%</span></div><div class="progress-bar"><div class="progress-bar-fill" style="width:${completeP}%;"></div></div>` : ''}
                </div>
                <div class="reward-status">
                    <div class="detail-row"><span class="detail-label">Total Earned</span><span class="detail-value">${fmt(earned,4)} ${s.coin}</span></div>
                    <div class="detail-row"><span class="detail-label">Claimed</span><span class="detail-value" style="color:var(--txt-1);">${fmt(s.rewardsWithdrawn||0,4)} ${s.coin}</span></div>
                </div>
                <div style="display:flex; gap:10px; margin-top:15px;">
                    <button class="btn primary" style="flex:1;" onclick="withdrawLockedStake('${id}')" ${canW&&!isPending?'':'disabled'}>Withdraw Locked</button>
                    <button class="btn" style="flex:1;" onclick="collectRewards('${id}')" ${avail>0.000001&&!isPending&&canW?'':'disabled'}>Collect Rewards</button>
                </div>
                ${!isPending&&!canW ? `<p class="status-msg">Withdrawal requires ${fmt(reqComp*100,0)}% completion.</p>` : ''}
                ${isPending ? `<p class="status-msg" style="color:var(--warn);text-align:center;">Awaiting Admin.</p>` : ''}
            </div>`;
        }
        document.getElementById('totalStakedValue').textContent = '$' + fmt(totalStakedUSD);
        document.getElementById('totalAvailableRewards').textContent = '$' + fmt(totalAvailRewardsUSD);
        document.getElementById('withdrawRewardsBtn').disabled = !hasActive;
    }

    async function confirmStake() {
        const coin = document.getElementById('stakeCoin').value, amount = parseFloat(document.getElementById('stakeAmount').value);
        const locked = Object.values(activeStakes).reduce((a,s)=>(s.coin===coin&&(s.status==='ACTIVE'||s.status==='PENDING')?a+parseFloat(s.amount):a),0);
        const avail = (userBalances[coin]||0) - locked;
        if (isNaN(amount) || amount <= 0) return await showAlert('Invalid amount.');
        if (amount > avail) return await showAlert(`Insufficient ${coin}. Available: ${fmt(avail,4)}`);
        
        const usd = amount * (latestPrices[coin]?.price||0);
        const rate = getRateForUsdAmount(usd);
        if(!await showConfirm(`Stake ${fmt(amount,4)} ${coin}?\nRate: ${(rate*100).toFixed(2)}% / ${GLOBAL_REWARD_PERIOD_TEXT}`)) return;
        
        const ref = database.ref('userStakes/' + userId).push();
        await ref.set({ id: ref.key, coin, amount: amount.toFixed(4), durationDays: FIXED_DURATION_DAYS, startTime: 0, dailyRate: rate, rewardsWithdrawn: 0, status: 'PENDING' });
        await showAlert('Staking request submitted!');
        document.getElementById('stakeAmount').value = '';
        setTimeout(() => database.ref('userStakes/'+userId+'/'+ref.key).update({status:'ACTIVE',startTime:Date.now()}), 8000); 
    }

    async function collectRewards(id) {
        const s = activeStakes[id];
        if(!s||s.status==='PENDING') return;
        const earned = Math.floor((Date.now()-s.startTime)/GLOBAL_REWARD_PERIOD_MS) * parseFloat(s.amount) * s.dailyRate;
        const avail = earned - parseFloat(s.rewardsWithdrawn);
        if(avail < 0.000001) return await showAlert('No rewards.');
        if(!await showConfirm(`Collect ${fmt(avail,4)} ${s.coin}?`)) return;
        
        const updates = {};
        updates[USER_HOLDINGS_PATH+userId+'/'+s.coin+'/hold'] = (userBalances[s.coin]||0) + avail;
        updates['userStakes/'+userId+'/'+id+'/rewardsWithdrawn'] = parseFloat(s.rewardsWithdrawn) + avail;
        await database.ref().update(updates);
        await showAlert('Rewards collected!');
    }

    async function withdrawLockedStake(id) {
        const s = activeStakes[id];
        if(!s||s.status==='PENDING') return;
        const locked = parseFloat(s.amount);
        if(!await showConfirm(`Withdraw locked ${fmt(locked,4)} ${s.coin}?`)) return;
        const updates = {};
        updates[USER_HOLDINGS_PATH+userId+'/'+s.coin+'/hold'] = (userBalances[s.coin]||0) + locked;
        updates['userStakes/'+userId+'/'+id] = null;
        await database.ref().update(updates);
        await showAlert('Stake withdrawn.');
    }

    async function withdrawAllRewards() {
        let total = 0, collected = {}, updates = {};
        for(const id in activeStakes) {
            const s = activeStakes[id]; if(s.status==='PENDING') continue;
            const comp = (Date.now()-s.startTime)/(s.durationDays*86400000);
            const req = getMinWithdrawPercentage(parseFloat(s.amount)*(latestPrices[s.coin]?.price||0));
            if(comp < req) continue;
            const earned = Math.floor((Date.now()-s.startTime)/GLOBAL_REWARD_PERIOD_MS) * parseFloat(s.amount) * s.dailyRate;
            const avail = earned - parseFloat(s.rewardsWithdrawn);
            if(avail>0.000001) { total+=avail; collected[s.coin]=(collected[s.coin]||0)+avail; updates['userStakes/'+userId+'/'+id+'/rewardsWithdrawn']=parseFloat(s.rewardsWithdrawn)+avail; }
        }
        if(total<0.000001) return await showAlert('No eligible rewards.');
        if(!await showConfirm('Collect all eligible rewards?')) return;
        for(const c in collected) updates[USER_HOLDINGS_PATH+userId+'/'+c+'/hold'] = (userBalances[c]||0)+collected[c];
        await database.ref().update(updates);
        await showAlert('All rewards collected!');
    }

    document.addEventListener('DOMContentLoaded', () => {
        document.getElementById('stakeCoin').addEventListener('change', updateStakeFormInfo);
        updateStakeFormInfo();
        setInterval(() => { if(Object.keys(activeStakes).length > 0) renderActiveStakes(); }, 1000);
    });
  </script>
</body>
</html>